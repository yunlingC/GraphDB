#ifndef _BREADTH_FIRST_SEARCH_H_
#define _BREADTH_FIRST_SEARCH_H_

#include <queue>
#include <map>
#include <vector>

#include "GraphType.h"
#include "VertexVisitor.h_"
#include "EdgeVisitor.h"
#include "Filter.h"
////#include "TraversalDescription.h"
#include "Collector.h"

using namespace std;

template<typename vertexVisitor,typename edgeVisitor>
void breadth_first_search(GraphType::VertexDescriptor vs, GraphType & g, VertexVisitor<vertexVisitor> & vv, EdgeVisitor< edgeVisitor> & ve){
  typedef pair<GraphType::VertexPtr, bool> VisitPair;
  typedef vector<GraphType::VertexPtr> VertexPath;
 
  vector<VertexPath> Paths;
//  typedef vector<Graph::VertexPtr> Path;
  cout << "================= BfS ===================== \n";
  GraphType::VertexPtr np = g.getVertexPointer(vs);
  bool tflag = 1; //
  bool eflag = 1;

  // Start traversing the graph from here. 
  std::queue<GraphType::VertexPtr> Q;
  std::map<GraphType::VertexPtr, bool> C; // true = visited, false = not visited
/**
 * use VertexPath to record path info 
 * use queue to assist recording 
 * */
  queue<VertexPath> pathQueue;

  Q.push(np);
  C.insert(VisitPair(np,false));

  VertexPath newPath;
  newPath.push_back(np);
  pathQueue.push(newPath);

  GraphType::VertexPtr targetVertex = nullptr;

  while (!Q.empty()) {
    np = Q.front();  Q.pop();

    if(!pathQueue.empty()) {
      newPath = pathQueue.front();
      pathQueue.pop();
    }

    tflag = vv.visitVertex(np); 
//      if (tflag == false)   //if true, add  np to targetset
//        return ;  
   /// update path; 
   /// if true, increment counter of this path
   
   ///checkTerminator() 
   ///if true, return all paths and terminate

    // Set to visited.    
    C[np] = true;

    GraphType::EdgePtr nextEdge = np->getNextEdge();
//    if(nextEdge == nullptr) {
//      cout << "push new path of " << newPath.size() << " vertex\n";
//      Paths.push_back(newPath);
//    }

    while (nextEdge != nullptr) {
      // Get the target
      eflag = ve.visitEdge(nextEdge);
      if (eflag == false)
        return;

      /// update path;
      /// if true, increment counter of this path;
      /// if not, terminate this path;

      ///checkTerminator() 
      


      targetVertex = nextEdge->getTarget(np);

//      VertexPath branchPath;
//      branchPath = newPath;
//      branchPath.push_back(targetVertex);
//      pathQueue.push(branchPath);
     



      if (C.find(targetVertex) == C.end()) {
	// queue the target for visitation
      VertexPath branchPath;
      branchPath = newPath;
      branchPath.push_back(targetVertex);
      pathQueue.push(branchPath);
     

      	eflag = ve.scheduleEdge(nextEdge);
	      tflag = vv.scheduleVertex(targetVertex);
//        if ((eflag == true) && (tflag == true)) {  
          Q.push(targetVertex);
          cout << "push vertex: " << targetVertex->getId() << endl;
//        }

        /// if true, go through this edge/relationship
        /// if not, terminate this path

 	      C.insert(VisitPair(targetVertex,false));
      }
      // Update nextEdge from np
      nextEdge = nextEdge->getNextEdge(np);
      if(nextEdge == nullptr) {
      cout << "push new path of " << newPath.size() << " vertex\n";
      Paths.push_back(newPath);
      }
    }
  }
  cout << "================= END BFS ===================== \n";
  cout << "print out " << Paths.size() << "paths"<< endl;
  int i = 1;
  for(vector<VertexPath>::iterator it = Paths.begin(); it != Paths.end(); ++it) {
    cout << "path  " << i ;
    i++;
    for(VertexPath::iterator iter = it->begin(); iter != it->end(); ++iter) {
      GraphType::VertexPtr vp = *iter;
    cout << "\tvertex id  "<< vp->getId() << "\t";
    }
    cout << "\n";
  }
};

#endif /* _BREADTH_FIRST_SEARCH_H_ */ 
